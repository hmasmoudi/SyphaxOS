--- xorg-server-1.19.6/hw/xwayland/xwayland.c	2017-12-20 21:32:33.000000000 +0100
+++ xorg-server-1.19.6/hw/xwayland/xwayland.c	2018-01-24 18:28:45.779041975 +0100
@@ -496,6 +496,7 @@
     BoxPtr box;
     struct wl_buffer *buffer;
     PixmapPtr pixmap;
+    int i;
 
     xorg_list_for_each_entry_safe(xwl_window, next_xwl_window,
                                   &xwl_screen->damage_window_list, link_damage) {
@@ -516,9 +517,20 @@
 
         wl_surface_attach(xwl_window->surface, buffer, 0, 0);
 
-        box = RegionExtents(region);
-        wl_surface_damage(xwl_window->surface, box->x1, box->y1,
-                          box->x2 - box->x1, box->y2 - box->y1);
+        /* Arbitrary limit to try to avoid flooding the Wayland
+        * connection. If we flood it too much anyway, this could
+        * abort in libwayland-client.
+        */
+        if (RegionNumRects(region) > 256) {
+            box = RegionExtents(region);
+            wl_surface_damage(xwl_window->surface, box->x1, box->y1,
+                              box->x2 - box->x1, box->y2 - box->y1);
+        } else {
+            box = RegionRects(region);
+            for (i = 0; i < RegionNumRects(region); i++, box++)
+                wl_surface_damage(xwl_window->surface, box->x1, box->y1,
+                                  box->x2 - box->x1, box->y2 - box->y1);
+        }
 
         xwl_window->frame_callback = wl_surface_frame(xwl_window->surface);
         wl_callback_add_listener(xwl_window->frame_callback, &frame_listener, xwl_window);
